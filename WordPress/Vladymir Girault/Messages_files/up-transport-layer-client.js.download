(function (global, factory) {
  if (typeof define === "function" && define.amd) {
    define(['exports', 'atmosphere', 'debug', 'Promise'], factory);
  } else if (typeof exports !== "undefined") {
    factory(exports, require('atmosphere'), require('debug'), require('Promise'));
  } else {
    var mod = {
      exports: {}
    };
    factory(mod.exports, global.atmosphere, global.debug, global.Promise);
    global.upTransportLayerClient = mod.exports;
  }
})(this, function (exports, _atmosphere, _debug, _Promise) {
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.TLSocket = exports.TLMetric = undefined;
  exports.createSocket = createSocket;
  exports.configure = configure;
  exports.getDefaultSocket = getDefaultSocket;

  var _atmosphere2 = _interopRequireDefault(_atmosphere);

  var _debug2 = _interopRequireDefault(_debug);

  var _Promise2 = _interopRequireDefault(_Promise);

  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
      default: obj
    };
  }

  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  var _createClass = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }

    return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);
      if (staticProps) defineProperties(Constructor, staticProps);
      return Constructor;
    };
  }();

  // Debug output
  var log = {
    connection: (0, _debug2.default)('atmosphere-client:connection'),
    connectionRaw: (0, _debug2.default)('atmosphere-client:connection-raw'),
    incoming: (0, _debug2.default)('atmosphere-client:incoming'),
    incomingRaw: (0, _debug2.default)('atmosphere-client:incoming-raw'),
    outgoing: (0, _debug2.default)('atmosphere-client:outgoing'),
    outgoingRaw: (0, _debug2.default)('atmosphere-client:outgoing-raw')
  };

  var INITIAL_RECONNECT_PING = 10;
  var INITIAL_THROTTLING_PING = 60;
  var CONNECT_TIMEOUT = 25000;
  var EVENTS_DATA_MAX_SIZE = 10000;
  var EVENTS_MAX_COUNT = 500;
  var MAX_FRAME_SIZE = 3 * 1000 * 1000;
  var TOO_MANY_REQUEST_WAIT = 1000;
  var TOO_MANY_REQUESTS_STATUS_CODE = 429;
  var CONN_CLOSED_EVENT = 'CONNECTION_CLOSED';
  var CONN_CLOSED_REASON_CONNS_LIMIT_REACHED = 'CONN_CLOSED_REASON_CONNS_LIMIT_REACHED';
  var CONN_CLOSED_REASON_THROTTLING = 'CLOSING_CONNECTION_DUE_TO_THROTTLING';
  var CONN_STATUS_CLOSE = 'close';
  var CONN_STATUS_RECONNECTING = 'reconnecting';
  var CONN_STATUS_DISCONNECT = 'disconnect';
  var CONN_SUCCESS_EVENT = 'CONNECTION_SUCCESS';

  // Due to some weirdness in ES6Promise Polyfill library with CommonJS (which UTA uses)
  // we need to check this to make sure we get the right ES6Promise class
  var PromiseClass = _Promise2.default.Promise ? _Promise2.default.Promise : _Promise2.default;

  /**
   * Simple class that pings every 60 seconds to keep the connection alive
   */

  var KeepAlivePing = function () {
    function KeepAlivePing(socket) {
      var pingInterval = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 60;

      _classCallCheck(this, KeepAlivePing);

      this.socket = socket;
      this.pingInterval = pingInterval;
    }

    _createClass(KeepAlivePing, [{
      key: 'start',
      value: function start() {
        var that = this;
        this.stop();
        this.pingTimeoutId = window.setInterval(function () {
          that._ping();
        }, that.pingInterval * 1000);
      }
    }, {
      key: 'stop',
      value: function stop() {
        if (this.pingTimeoutId) {
          window.clearInterval(this.pingTimeoutId);
          this.pingTimeoutId = null;
        }
      }
    }, {
      key: '_ping',
      value: function _ping() {
        this.socket.send('core.ping');
      }
    }]);

    return KeepAlivePing;
  }();

  var CountdownTimer = function () {
    function CountdownTimer(fn, timeInSeconds) {
      _classCallCheck(this, CountdownTimer);

      this.fn = fn;
      this.wasCalled = false;
      this.timeInSeconds = timeInSeconds;
      this._start();
    }

    _createClass(CountdownTimer, [{
      key: '_start',
      value: function _start() {
        var that = this;
        this.timerId = window.setInterval(function () {
          that._step();
        }, 1000);
      }
    }, {
      key: '_step',
      value: function _step() {

        if (this.wasCalled) {
          return;
        }

        this.timeInSeconds -= 1;
        if (this.timeInSeconds <= 0) {
          this.wasCalled = true;
          this.stop();
          this.fn();
        }
      }
    }, {
      key: 'stop',
      value: function stop() {
        window.clearInterval(this.timerId);
      }
    }, {
      key: 'getCountdown',
      value: function getCountdown() {
        return this.timeInSeconds;
      }
    }]);

    return CountdownTimer;
  }();

  var ReconnectPing = function () {
    function ReconnectPing(socket) {
      _classCallCheck(this, ReconnectPing);

      this.socket = socket;
      this.pingInterval = this.getInitialPingInterval();
    }

    /**
     * Returns a random integer between the min and max passed as parameter
     * @param  {int} min
     * @param  {max} max
     * @return {int}
     */


    _createClass(ReconnectPing, [{
      key: 'getRandomInt',
      value: function getRandomInt(min, max) {
        return Math.floor(Math.random() * (max - min + 1)) + min;
      }
    }, {
      key: 'getInitialPingInterval',
      value: function getInitialPingInterval() {
        return this.getRandomInt(INITIAL_RECONNECT_PING, INITIAL_RECONNECT_PING * 2);
      }
    }, {
      key: 'activateThrottling',
      value: function activateThrottling() {
        var throttlingPing = this.getRandomInt(INITIAL_THROTTLING_PING, INITIAL_THROTTLING_PING * 2);
        this.pingInterval = Math.max(this.pingInterval, throttlingPing);
      }
    }, {
      key: 'start',
      value: function start() {
        var that = this;
        this.stop();
        this.countdownTimer = new CountdownTimer(function () {
          that._ping();
        }, that.pingInterval);
        if (this.resetTimer) {
          clearTimeout(this.resetTimer);
        }
      }
    }, {
      key: 'reset',
      value: function reset() {
        var that = this;

        // We dont reset the pingInterval right away, only after a couple of minutes
        // This is to avoid many connect / reconnect cycles if the server is not
        // behaving correctly
        this.resetTimer = setTimeout(function () {
          that.pingInterval = that.getInitialPingInterval();
          that.resetTimer = null;
        }, 300 * 1000);

        this.stop();
      }
    }, {
      key: 'stop',
      value: function stop() {
        if (this.countdownTimer) {
          this.countdownTimer.stop();
          this.countdownTimer = null;
        }
      }
    }, {
      key: 'getCountdown',
      value: function getCountdown() {
        return this.countdownTimer ? this.countdownTimer.getCountdown() : 0;
      }
    }, {
      key: '_ping',
      value: function _ping() {
        this.stop();
        this.socket.reconnect();
        this.pingInterval += this.pingInterval;
        var minPingInterval = this.getRandomInt(60, 90);
        this.pingInterval = Math.max(minPingInterval, Math.min(this.pingInterval, 300));
        this.start();
      }
    }]);

    return ReconnectPing;
  }();

  var TLMetric = exports.TLMetric = function () {
    function TLMetric(socket) {
      var flushInterval = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 10000;

      _classCallCheck(this, TLMetric);

      var that = this;

      if (flushInterval === 0) {
        throw new Error('flushInterval cannot be zero');
      }

      this.socket = socket;
      this.flushInterval = flushInterval;
      this.queue = [];
      this.measurements = {};

      window.setInterval(function () {
        that._flush();
      }, that.flushInterval);
    }

    _createClass(TLMetric, [{
      key: 'start',
      value: function start(name, time) {
        this.measurements[name] = {
          name: name,
          time: time || Date.now()
        };
      }
    }, {
      key: 'stop',
      value: function stop(name, time) {
        var measurement = this.measurements[name];
        if (measurement) {
          measurement.time = (time || Date.now()) - measurement.time;
          this.queue.push(measurement);
          delete this.measurements[name];
        }
      }
    }, {
      key: '_flush',
      value: function _flush() {
        if (this.queue.length) {
          if (this.socket.isConnected()) {
            this.socket.emit('metric.batch', {
              list: this.queue
            });
          }
          this.queue = [];
        }
      }
    }]);

    return TLMetric;
  }();

  var CircularBuffer = function () {
    function CircularBuffer(capacity) {
      _classCallCheck(this, CircularBuffer);

      this.capacity = capacity;
      this.buffer = [];
      this.length = 0;
      this.pointer = 0;
    }

    _createClass(CircularBuffer, [{
      key: 'get',
      value: function get(key) {
        return this.buffer[key];
      }
    }, {
      key: 'push',
      value: function push(item) {
        this.buffer[this.pointer] = item;
        this.pointer = (this.capacity + this.pointer + 1) % this.capacity;
        this.length = this.buffer.length;
      }
    }, {
      key: 'all',
      value: function all() {
        if (this.pointer === 0 || this.buffer.length < this.capacity) {
          return this.buffer;
        }
        return this.buffer.slice(this.pointer).concat(this.buffer.slice(0, this.pointer));
      }
    }]);

    return CircularBuffer;
  }();

  var TLSocket = exports.TLSocket = function () {
    function TLSocket(atmosphere, baseUrl, options) {
      _classCallCheck(this, TLSocket);

      this.baseUrl = baseUrl;
      this.messageQueue = [];
      this.requests = {};
      this.requestIdSeq = 1;
      this.eventHandlers = {};
      this.query = {};
      this.logErrors = true;
      this.atmosphere = atmosphere;
      this.ackTimeout = options && options.ackTimeout || 30000;
      this.online = true;
      this.eventsMaxCount = options && options.eventsMaxCount || EVENTS_MAX_COUNT;
      this.eventsDataMaxSize = options && options.eventsDataMaxSize || EVENTS_DATA_MAX_SIZE;
      this.events = new CircularBuffer(this.eventsMaxCount);
      this.trackMessageLength = options && options.trackMessageLength === false ? false : true;
      if (options && options.metric && options.metric.enabled) {
        this.tlMetric = new TLMetric(this, options.metric.flushInterval);
      }
      this.libVersion = '2.66.0';
      this.keepAlivePing = new KeepAlivePing(this);
      this.reconnectPing = new ReconnectPing(this);

      if (options && options.query) {
        this.query = options.query;
      }

      if (!this.query.app) {
        this.query.app = 'other';
      }

      this.query.libVersion = this.libVersion;

      if (this.trackMessageLength) {
        this.query.tml = this.trackMessageLength;
      }
      this._startOnlineCheck();
    }

    _createClass(TLSocket, [{
      key: '_addEvent',
      value: function _addEvent(eventType, data) {

        var event = {
          timestamp: Date.now(),
          eventType: eventType
        };

        if (typeof data !== 'undefined') {
          event.data = data;
        }

        if (typeof data === 'string') {
          event.data = data.substring(0, this.eventsDataMaxSize);
        }

        this.events.push(event);
      }
    }, {
      key: '_push',
      value: function _push(data) {

        if (this.tlMetric && data.requestId) {
          this.tlMetric.start('rid:' + data.requestId);
        }

        var body = this.atmosphere.util.stringifyJSON(data);

        /*
          Drops the request is the length is bigger than the max frame size
          It will reject the request promise in case it exists
         */
        if (body.length > MAX_FRAME_SIZE) {
          console.warn('Request max frame size limit excedded, dropping frame');
          var request;
          if (data.requestId && (request = this.requests[data.requestId])) {
            request.promise.reject({
              type: 'error',
              message: 'Request max frame size limit excedded'
            });
          }
          return;
        }

        this.socket.push(body);

        if (data.eventName === 'auth') {
          if (data.args && data.args.password) {
            data = _atmosphere2.default.util.parseJSON(body); //dereference original data variable
            data.args.password = '******'; //obfuscate password for logging
            body = _atmosphere2.default.util.stringifyJSON(data);
          }
        }
        log.outgoingRaw(body);
        log.outgoing(data);
        this._addEvent('out', body);
      }
    }, {
      key: '_pushWhenConnected',
      value: function _pushWhenConnected(data) {
        if (this.isConnected()) {
          this._push(data);
        } else {
          this.messageQueue.push(data);
        }
      }
    }, {
      key: '_resetMessageQueue',
      value: function _resetMessageQueue() {
        this.messageQueue.length = 0;
      }
    }, {
      key: '_processMessageQueue',
      value: function _processMessageQueue() {
        this._forEach(this.messageQueue, this._push);
        this._resetMessageQueue();
      }
    }, {
      key: '_changeSocketStatus',
      value: function _changeSocketStatus(status, data) {

        var origStatus = status;

        // If the status is close the we ignore every transition except reconnecting
        if (this.socketStatus === CONN_STATUS_CLOSE && status !== CONN_STATUS_RECONNECTING) {
          return;
        }

        // Consider clientTimeout or error same as disconnect
        if (status === 'clientTimeout' || status === 'error') {
          status = CONN_STATUS_DISCONNECT;
        }

        // Reconnect is the right state if we were ever connected
        if (status === 'reconnect' || status === 'connect') {
          status = this.wasConnected ? 'reconnect' : 'connect';
        }

        log.connectionRaw('setting status to ' + status + ' | ' + origStatus);

        if (this.socketStatus !== status) {

          // Status was connect now is disconnect, start the reconnect ping
          if (['connect', 'reconnect', 'offline'].indexOf(this.socketStatus) >= 0 && status === CONN_STATUS_DISCONNECT && this.wasConnected) {
            this.keepAlivePing.stop();
            this.reconnectPing.start();
          }

          // Ofline state we should not ping at all until it becomes online again
          if (status === 'offline') {
            this.keepAlivePing.stop();
            this.reconnectPing.reset();
          }

          // We are connected now, reset everything
          if (status === 'connect' || status === 'reconnect') {
            log.connectionRaw('starting keep alive ping');
            this.wasConnected = true;
            this._processMessageQueue();
            this.keepAlivePing.start();
            this.reconnectPing.reset();
          }

          this.socketStatus = status;
          this.dispatchEvent(status, data);
        }
      }
    }, {
      key: '_setOnline',
      value: function _setOnline(value) {
        if (this.online !== value) {
          this.online = value;
          if (!value) {
            this._changeSocketStatus('offline');
          } else {
            this._changeSocketStatus(CONN_STATUS_DISCONNECT);
            this.reconnect();
          }
        }
      }
    }, {
      key: '_startOnlineCheck',
      value: function _startOnlineCheck() {
        var that = this;

        var supported = 'onLine' in window.navigator;

        if (supported) {
          // Sometimes this flag goes out of sync cause the event is not called properly
          // Make it online again in that case
          window.setInterval(function () {
            if (!that.online && window.navigator.onLine) {
              that._setOnline(true);
            }
          }, 3000);

          this.atmosphere.util.on(window, 'online', function () {
            that._setOnline(true);
          });

          this.atmosphere.util.on(window, 'offline', function () {
            that._setOnline(false);
          });
        }
      }
    }, {
      key: 'dispatchEvent',
      value: function dispatchEvent(eventName, data) {
        var handlers = this.eventHandlers[eventName];
        if (handlers && handlers.length) {
          this._forIn(handlers, function (handler) {
            handler(data);
          });
        }
      }
    }, {
      key: '_logError',
      value: function _logError() {
        var args = Array.prototype.slice.call(arguments);
        if (this.debug || this.logErrors) {
          args.unshift('[transport-layer-client]');
          console.error.apply(console, args);
        }
      }
    }, {
      key: '_cleanSocket',
      value: function _cleanSocket() {
        var deferrerSocket = this.socket;
        this.socket = null;
        if (deferrerSocket) {
          this.atmosphere.unsubscribe();
        }

        this._forIn(this.requests, function (request) {
          request.promise.reject([{
            type: 'connect',
            message: 'Sorry, but there was an issue communicating with the server.'
          }]);
        });

        this.requests = {};
        this._resetMessageQueue();
        this.requestIdSeq = 1;
      }
    }, {
      key: '_connect',
      value: function _connect() {
        var that = this;
        if (this.socket) {
          return;
        }

        var urlParts = this.baseUrl.split('?');
        var requestUrl = urlParts[0];

        if (this.oldConnId) {
          this.query.connIdsToClose = this.oldConnId;
        }

        if (this.query) {
          requestUrl += '?';
          var queryArr = [];
          this._forIn(this.query, function (val, key) {
            queryArr.push(key + '=' + encodeURIComponent(val));
          });
          requestUrl += queryArr.join('&');
        }

        var request = new this.atmosphere.AtmosphereRequest().request;

        request.url = requestUrl;
        request.enableXDR = true;
        request.transport = 'websocket';
        request.fallbackTransport = 'none';
        request.reconnect = false;
        request.connectTimeout = CONNECT_TIMEOUT;
        request.reconnectInterval = 300000;
        request.timeout = 90000;
        request.maxReconnectOnClose = 100;
        request.closeAsync = true;
        request.trackMessageLength = that.trackMessageLength;

        var socketEvents = {
          connect: 'Open',
          disconnect: 'Close',
          reconnecting: 'Reconnect',
          reconnect: 'Reopen',
          error: 'Error',
          clientTimeout: 'ClientTimeout'
        };

        // Generate general hook to manage future event subscriptions
        that._forIn(socketEvents, function (internalEventName, eventName) {
          request['on' + internalEventName] = function (atmosphereResponse) {

            log.connection(eventName);
            log.connectionRaw(eventName);

            that._addEvent(eventName, atmosphereResponse.responseBody);

            if (eventName === that.socketStatus) {
              return;
            }

            if (eventName === 'error' || eventName === CONN_STATUS_DISCONNECT || eventName === 'clientTimeout') {
              that._cleanSocket();
            }

            var data = {};
            try {
              if (eventName === 'error') {
                data = atmosphereResponse.reasonPhrase;
              } else if (eventName === 'connect') {
                if (atmosphereResponse.request) {
                  data = atmosphereResponse.request.uuid;
                  that.oldConnId = data;
                }
              } else {
                data = that.atmosphere.util.parseJSON(atmosphereResponse.responseBody);
              }
            } catch (e) {}

            that._changeSocketStatus(eventName, data);
          };
        });

        request.onMessage = function (atmosphereResponse) {
          var time = Date.now(); // get time for metric
          var body = atmosphereResponse.responseBody;
          that.lastMessageTimestamp = time;

          log.incomingRaw(body);
          that._addEvent('in', body);

          try {
            body = that.atmosphere.util.parseJSON(body);
            log.incoming(body);
          } catch (e) {
            if (body !== 'X') {
              // this is the atmosphere keep alive, no need to inform about that
              that._logError('failed to parse response body:', e, body);
            }
          }

          if (!that.isConnected()) {
            // if we receive a message, we are connected!?
            // sync status
            if (body.connectionId) {
              that.oldConnId = body.connectionId;
            }
            that._changeSocketStatus('connect');
          }

          var requestId = body.requestId;
          var request = requestId && that.requests[requestId];
          if (request) {
            if (that.tlMetric) {
              that.tlMetric.stop('rid:' + requestId, time);
            }
            window.clearTimeout(request.timeoutId);
            var promise = request.promise;
            delete that.requests[requestId];
            if (body.errors) {
              // Resent request after sometime if we got TOO_MANY_REQUEST error
              // We only do this once, if it fails again we reject the original promise
              if (body.errors[0].code === TOO_MANY_REQUESTS_STATUS_CODE && request.tries < 2) {
                setTimeout(function () {
                  that._send(request);
                }, TOO_MANY_REQUEST_WAIT);
                return;
              }
              promise.reject(body.errors);
            } else {
              promise.resolve(body.data);
            }
          } else {
            var eventName = body.eventName;
            if (eventName) {

              // Notify upper layers about the event
              that.dispatchEvent(eventName, body.data);

              if (eventName === CONN_CLOSED_EVENT && body.data) {

                switch (body.data.reason) {

                  case CONN_CLOSED_REASON_CONNS_LIMIT_REACHED:
                    // For some critical events we closed the connection for good until the user
                    // resume it explicitly
                    that.close(body.data.reason);
                    break;

                  case CONN_CLOSED_REASON_THROTTLING:
                    // We increase the reconnect ping interval so we dont connect to TL
                    // right away
                    that.reconnectPing.activateThrottling();
                    that._cleanSocket();
                    break;

                  default:
                    // For other we just close the current connection just in case
                    // It should be closed by server side anyway
                    that._cleanSocket();

                }
              }
            } else if (body.errors && body.errors.length && requestId === 0) {
              that._forIn(that.requests, function (req) {
                req.promise.reject(body.errors);
              });
              that.requests = {};
            } else if (body.type) {
              that.dispatchEvent(body.type, body);
            } else if (requestId === 0) {
              // manually despatch event for connections success
              that.dispatchEvent(CONN_SUCCESS_EVENT, body.data);
            }
          }
        };

        that.socket = that.atmosphere.subscribe(request);
      }
    }, {
      key: 'isClosed',
      value: function isClosed() {
        return this.socketStatus === CONN_STATUS_CLOSE;
      }
    }, {
      key: 'reconnect',
      value: function reconnect() {
        this._changeSocketStatus(CONN_STATUS_RECONNECTING);
        this.send('core.ping');
      }
    }, {
      key: 'close',
      value: function close(reason) {
        this._changeSocketStatus(CONN_STATUS_CLOSE, reason);
        return this.disconnect();
      }
    }, {
      key: 'disconnect',
      value: function disconnect() {
        this.wasConnected = false;
        log.connection('explicit disconnect');
        this._addEvent('explicitDisconnect');
        this.keepAlivePing.stop();
        this.reconnectPing.stop();
        this._forIn(this.requests, function (req) {
          req.promise.reject({
            errors: [{
              type: 'connect',
              message: 'Sorry, but there was an issue communicating with the server.'
            }]
          });
        });
        this._cleanSocket();
      }
    }, {
      key: 'getSocketStatus',
      value: function getSocketStatus() {
        return this.socketStatus;
      }
    }, {
      key: 'getReconnectCountdown',
      value: function getReconnectCountdown() {
        return this.reconnectPing.getCountdown();
      }
    }, {
      key: 'isConnected',
      value: function isConnected() {
        return this.socket && (this.socketStatus === 'connect' || this.socketStatus === 'reconnect');
      }
    }, {
      key: 'getEvents',
      value: function getEvents() {
        return this.events.all();
      }
    }, {
      key: 'getLastMessageTimestamp',
      value: function getLastMessageTimestamp() {
        return this.lastMessageTimestamp;
      }

      // Event management

    }, {
      key: 'on',
      value: function on(eventName, handler) {
        var that = this;

        if (!this.eventHandlers[eventName]) {
          that.eventHandlers[eventName] = [];
        }
        that.eventHandlers[eventName].push(handler);
        //return the deregistration function
        return function () {
          that._off(eventName, handler);
        };
      }
    }, {
      key: '_off',
      value: function _off(eventName, handler) {
        var handlers = this.eventHandlers[eventName];
        var index = handlers && handlers.indexOf(handler);
        if (handlers && index !== -1) {
          handlers.splice(index, 1);
        }
      }
    }, {
      key: '_getNextRequestId',
      value: function _getNextRequestId() {
        return this.requestIdSeq++;
      }
    }, {
      key: '_send',
      value: function _send(request) {
        var that = this;
        var requestId = this._getNextRequestId();
        var ackTimeout = this.ackTimeout;

        if (_debug2.default.enabled('atmosphere-client:latency')) {
          ackTimeout = ackTimeout * 2;
        }

        this._connect();

        request.requestId = requestId;
        this.requests[requestId] = request;

        request.timeoutId = window.setTimeout(function () {
          var request = that.requests[requestId];
          if (request && request.promise) {
            if (that.tlMetric) {
              that.tlMetric.stop('rid:' + requestId);
            }
            request.promise.reject([{
              type: 'timeout',
              message: 'Sorry, but there was an issue communicating with the server.',
              data: {
                timeout: that.ackTimeout,
                args: [request.eventName, request.args]
              }
            }]);
            delete that.requests[requestId];
          }
        }, ackTimeout);

        request.tries++;

        var dataObj = {
          requestId: request.requestId,
          eventName: request.eventName,
          eventType: request.eventType,
          args: request.args
        };

        if (_debug2.default.enabled('atmosphere-client:latency')) {
          dataObj.latency = true;
        }

        this._pushWhenConnected(dataObj);
      }
    }, {
      key: 'send',
      value: function send(eventName, data) {

        if (this.isClosed()) {
          return PromiseClass.reject({
            type: CONN_STATUS_CLOSE,
            message: 'The connection is currently closed, no requests allowed'
          });
        }

        // Only allow ping if it's disconnected and reject all other commands
        // We only do this if a connection was established at some point, otherwise
        // we will reject the initial frames (e.g. auth) and we should avoid that
        if (eventName !== 'core.ping' && !this.isConnected() && this.wasConnected) {
          return PromiseClass.reject({
            type: CONN_STATUS_CLOSE,
            message: 'The connection is currently reconnecting, no requests allowed'
          });
        }

        var request = void 0;
        var p = new PromiseClass(function (resolve, reject) {
          request = {
            tries: 0,
            promise: {
              resolve: resolve,
              reject: reject
            },
            eventName: eventName,
            eventType: 'RPC',
            args: data
          };
        });

        this._send(request);

        return p;
      }
    }, {
      key: 'emit',
      value: function emit(eventName, data) {
        var dataObj = void 0;

        if (this.isClosed()) {
          return;
        }

        // Ignore everything if we are disconnected
        if (!this.isConnected() && this.wasConnected) {
          return;
        }

        this._connect();
        dataObj = {
          eventName: eventName,
          eventType: 'CLIENT_PUSH',
          data: data
        };
        this._pushWhenConnected(dataObj);
      }
    }, {
      key: '_forEach',
      value: function _forEach(arr, callback) {
        var i = 0;
        var data = void 0;
        while (data = arr[i++]) {
          callback.call(this, data);
        }
      }
    }, {
      key: '_forIn',
      value: function _forIn(obj, callback) {
        for (var key in obj) {
          callback.call(this, obj[key], key);
        }
      }
    }]);

    return TLSocket;
  }();

  var _url;
  var _options;
  var _socket;

  function createSocket(url, options) {
    return new TLSocket(_atmosphere2.default, url, options);
  }

  function configure(url, options) {
    _url = url;
    _options = options;
  }

  function getDefaultSocket() {
    if (!_socket) {
      _socket = createSocket(_url, _options);
    }
    return _socket;
  }
});
