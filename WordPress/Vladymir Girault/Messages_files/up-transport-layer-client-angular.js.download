(function (global, factory) {
  if (typeof define === "function" && define.amd) {
    define(['up-transport-layer-client', 'debug'], factory);
  } else if (typeof exports !== "undefined") {
    factory(require('up-transport-layer-client'), require('debug'));
  } else {
    var mod = {
      exports: {}
    };
    factory(global.upTransportLayerClient, global.debug);
    global.upTransportLayerClientAngular = mod.exports;
  }
})(this, function (_upTransportLayerClient, _debug) {
  'use strict';

  var tlClient = _interopRequireWildcard(_upTransportLayerClient);

  var _debug2 = _interopRequireDefault(_debug);

  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
      default: obj
    };
  }

  function _interopRequireWildcard(obj) {
    if (obj && obj.__esModule) {
      return obj;
    } else {
      var newObj = {};

      if (obj != null) {
        for (var key in obj) {
          if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
        }
      }

      newObj.default = obj;
      return newObj;
    }
  }

  var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
    return typeof obj;
  } : function (obj) {
    return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
  };

  var _module = angular.module('upwork.transport', []);

  var toArray = function toArray(arr) {
    return Array.prototype.slice.call(arr);
  };

  var getBrowser = function getBrowser() {
    var browser = window.navigator.userAgent;
    var results = [];
    results.push(browser.match(/PhantomJS/));
    results.push(browser.match(/Chrome\/\d+\.\d/));
    results.push(browser.match(/Firefox\/\d+\.\d/));
    results.push(browser.match(/Safari\/\d+\.\d/));
    results.push(browser.match(/MSIE \d+\.\d/));
    if (browser.match(/Trident.*rv[: ]\d+/)) {
      results.push('MSIE ' + browser.match(/rv[: ]\d+\.\d/));
    }
    results.push('Unknown');
    for (var i = 0; i < results.length; i++) {
      if (results[i]) {
        if (_typeof(results[i]) === 'object') {
          return results[i][0];
        } else {
          return results[i];
        }
      }
    }
  };

  _module.factory('logger', ['$filter', function ($filter) {
    return function (namespace) {
      // Unshift an empty string, to have the ms difference besides the event namespace
      return function () {
        var logger = (0, _debug2.default)(namespace);
        Array.prototype.unshift.call(arguments, '');
        Array.prototype.unshift.call(arguments, $filter('date')(new Date(), 'HH:mm:ss.sss'));
        logger.apply(this, arguments);
      };
    };
  }]);

  _module.provider('tlSocket', function () {

    var url = '/';
    var ACK_TIMEOUT = 3000;
    var trackMessageLength = true;
    var useEvalAsync = true;
    var metricOptions = {
      enabled: false,
      flushInterval: 10000
    };

    this.useEvalAsync = function (value) {
      useEvalAsync = value;
    };

    this.setUrl = function (URL) {
      url = URL;
    };

    this.setRPCTimeout = function (timeout) {
      ACK_TIMEOUT = timeout;
    };

    this.setTrackMessageLength = function (value) {
      trackMessageLength = value;
    };

    this.setMetricOptions = function (options) {
      metricOptions = options;
    };

    this.$get = ['$injector', '$rootScope', '$q', '$timeout', '$log', 'logger', function ($injector, $rootScope, $q, $timeout, $log, logger) {

      tlClient.configure(url, {
        trackMessageLength: trackMessageLength,
        metric: metricOptions
      });

      var tlSocket = tlClient.getDefaultSocket();
      var sudoMode = false;
      var methodsFilteredInSudoMode = ['updateRoomUser'];

      // Debug output
      var log = {
        connection: logger('atmosphere-client:connection'),
        performance: logger('atmosphere-client:performance')
      };

      tlSocket.on('disconnect', function () {
        log.connection('tlSocket.onDisconnect');
      });

      tlSocket.on('clientTimeout', function (response) {
        log.connection('tlSocket.onClientTimeout');
        $log.error({
          name: 'socket_error',
          logMessage: response,
          browser: getBrowser()
        });
      });

      tlSocket.on('error', function (response) {
        log.connection('tlSocket.onError');
        $log.error({
          name: 'socket_error',
          logMessage: response,
          browser: getBrowser()
        });
      });

      tlSocket.on('connect', function () {
        log.connection('tlSocket.onConnect');
      });

      var events = ['connect', 'disconnect', 'reconnecting', 'reconnect', 'error'];

      function safeApply(fn) {
        if (useEvalAsync) {
          $rootScope.$evalAsync(fn);
        } else {
          var phase = $rootScope.$$phase;
          if (phase === '$apply' || phase === '$digest') {
            if (fn && typeof fn === 'function') {
              fn();
            }
          } else {
            $rootScope.$apply(fn);
          }
        }
      }

      // proxies events from socket to $rootScope with 'socket:' prefix
      angular.forEach(events, function (eventName) {
        tlSocket.on(eventName, function () {
          var args = toArray(arguments);
          args.unshift('socket:' + eventName);
          safeApply(function () {
            $rootScope.$emit.apply($rootScope, args);
          });
        });
      });

      var ngSocket = {
        setBaseUrl: function setBaseUrl(url) {
          tlSocket.baseUrl = url;
        },
        query: tlSocket.query,
        tlVersion: tlSocket.tlVersion,
        tlProtocol: tlSocket.tlProtocol,
        connected: false,
        getReconnectCountdown: function getReconnectCountdown() {
          return tlSocket.getReconnectCountdown();
        },
        getConnectionId: function getConnectionId() {
          return tlSocket.oldConnId;
        },
        isConnected: function isConnected() {
          return tlSocket.isConnected();
        },
        disconnect: function disconnect() {
          tlSocket.disconnect();
          return $q.when({});
        },
        close: function close(reason) {
          tlSocket.close(reason);
          return $q.when({});
        },
        reconnect: function reconnect() {
          tlSocket.reconnect();
        },
        getLastMessageTimestamp: function getLastMessageTimestamp() {
          return tlSocket.getLastMessageTimestamp();
        },

        dispatchEvent: function dispatchEvent(eventName, data) {
          tlSocket.dispatchEvent(eventName, data);
        },
        emit: function emit() /* eventName, param1, param2 */{
          tlSocket.emit.apply(tlSocket, arguments);
        },
        send: function send() /* eventName, param1, param2 */{
          var args = toArray(arguments);
          var callApply = true;

          if (args.length > 2 && angular.isObject(args[2])) {
            var options = args[2];
            if (angular.isDefined(options.apply) && !options.apply) {
              callApply = false;
            }
          }

          var eventName = args[0];
          var deferred = $q.defer();
          var promise = deferred.promise;
          var performanceStart, performanceNetwork, performanceResolved, performanceApply;
          if (_debug2.default.enabled('atmosphere-client:performance')) {
            performanceStart = Date.now();
          }

          var resolve = function resolve(error, resp) {
            if (error) {
              deferred.reject(error);
              $rootScope.$emit.apply($rootScope, ['tl:errorResponse', eventName, error]);
            } else {
              deferred.resolve(resp);
            }
            performanceResolved = Date.now();
          };

          var handleResponse = function handleResponse(error, resp) {
            if (_debug2.default.enabled('atmosphere-client:performance')) {
              performanceNetwork = Date.now();
            }
            if (callApply) {
              safeApply(function () {
                resolve(error, resp);
              });
            } else {
              resolve(error, resp);
            }
            if (_debug2.default.enabled('atmosphere-client:performance')) {
              performanceApply = Date.now();
              log.performance('eventName:' + eventName + ', ' + 'network:' + (performanceNetwork - performanceStart) + 'ms, ' + 'resolved:' + '+' + (performanceResolved - performanceNetwork) + 'ms, ' + 'applied:' + '+' + (performanceApply - performanceResolved) + 'ms');
            }
          };

          tlSocket.send.apply(tlSocket, args).then(function (resp) {
            handleResponse(null, resp);
          }).catch(function (resp) {
            handleResponse(resp);
          });

          return promise;
        },
        on: function on(eventName, handler, options) {
          var callApply = true;
          if (angular.isDefined(options) && angular.isDefined(options.apply) && !options.apply) {
            callApply = false;
          }
          var fn = function fn() {
            var performanceStart, performanceCallback, performanceApply;
            if (_debug2.default.enabled('atmosphere-client:performance')) {
              performanceStart = Date.now();
              performanceCallback = performanceStart; //does nothing but appease jshint
            }
            var args = arguments;
            if (callApply) {
              safeApply(function () {
                handler.apply(this, args);
                performanceCallback = Date.now();
              });
            } else {
              handler.apply(this, args);
              performanceCallback = Date.now();
            }
            if (_debug2.default.enabled('atmosphere-client:performance')) {
              performanceApply = Date.now();
              log.performance('eventName:' + eventName + ', ' + 'callback:' + (performanceCallback - performanceStart) + 'ms, ' + 'applied:' + '+' + (performanceApply - performanceCallback) + 'ms');
            }
          };
          return tlSocket.on(eventName, fn);
        },
        setSudoMode: function setSudoMode(sudoModeSetting) {
          sudoMode = sudoModeSetting;
        },
        isSudoMode: function isSudoMode() {
          return sudoMode;
        },
        isMethodBlockedInSudo: function isMethodBlockedInSudo(method) {
          if (methodsFilteredInSudoMode.indexOf(method) >= 0) {
            return true;
          }
          return false;
        },
        getRejectedPromiseForSudo: function getRejectedPromiseForSudo(methodName) {
          var deferred = $q.defer();
          var promise = deferred.promise;
          deferred.reject('Sudo mode does not allow to call the ' + methodName + ' method.');
          return promise;
        },
        getEvents: function getEvents() {
          return tlSocket.getEvents();
        }
      };

      Object.defineProperty(ngSocket, 'connected', {
        get: function get() {
          return ngSocket.isConnected();
        },
        enumerable: true,
        configurable: true
      });

      return ngSocket;
    }];
  });

  _module.factory('tlDataFactory', ['tlSocket', function (tlSocket) {

    var factory;

    var baseObject = {
      $ns: function $ns(eventName, version) {
        var ns = this._ns;
        if (ns) {
          ns += '.';
        }
        if (version) {
          version += '.';
          return eventName ? ns + version + eventName : ns + version;
        }
        return eventName ? ns + eventName : ns;
      },
      $version: function $version(args) {
        var optionsArg = args[args.length - 1];
        if (optionsArg && (typeof optionsArg === 'undefined' ? 'undefined' : _typeof(optionsArg)) === 'object') {
          if (optionsArg.version) {
            return optionsArg.version;
          }
        }
        return false;
      },
      $module: function $module(methods, options) {
        var namespace = options && options.namespace || '';
        if (namespace) {
          options.namespace = this.$ns() + namespace;
          return factory(methods, options);
        }
      },
      $send: function $send(eventName) {
        var args = toArray(arguments);
        var version = this.$version(args);
        if (version) {
          args.pop(); //not sending the options obj
          args[0] = this.$ns(eventName, version);
        } else {
          args[0] = this.$ns(eventName);
        }
        return tlSocket.send.apply(tlSocket, args);
      },
      $emit: function $emit(eventName) {
        var args = toArray(arguments);
        args[0] = this.$ns(eventName);
        tlSocket.emit.apply(tlSocket, args);
      },
      $on: function $on(eventName, callback, options) {
        return tlSocket.on(this.$ns(eventName), callback, options);
      }
    };

    factory = function factory(methods, options) {
      var namespace = options && options.namespace || '';
      var DATA = angular.extend({
        _ns: namespace
      }, baseObject);
      angular.forEach(methods, function (methodOptions, methodName) {
        DATA[methodName] = function () {
          var args = toArray(arguments);
          args.unshift(methodName);

          // Make sure the default options don't override the specific options send
          // as last parameter
          if (angular.isObject(methodOptions) && methodOptions.version && args.length < 3) {
            args.push(methodOptions);
          }

          if (tlSocket.isSudoMode()) {
            if (tlSocket.isMethodBlockedInSudo(methodName)) {
              return tlSocket.getRejectedPromiseForSudo(methodName);
            }
          }
          return this.$send.apply(this, args);
        };
      });
      return DATA;
    };

    return factory;
  }]);

  var tlLogMethods = {
    // debug(data)
    'debug': {},
    // error(data)
    'error': {},
    // info(data)
    'info': {},
    // log(data)
    'log': {},
    // warn(data)
    'warn': {}
  };

  _module.provider('tlLog', function () {

    var baseUrl = '/api/';

    this.setBaseUrl = function (url) {
      baseUrl = url;
    };

    this.$get = ['$http', 'tlSocket', 'tlDataFactory', function ($http, tlSocket, tlDataFactory) {
      var tlLog = tlDataFactory(tlLogMethods, {
        namespace: 'log'
      });

      tlLog.$send = function () {
        var args = toArray(arguments);
        if (tlSocket.connected) {
          this.$emit.apply(this, args);
        } else {
          $http.post(baseUrl + 'log/' + args.shift(), args);
        }
      };

      return tlLog;
    }];
  });

  _module.provider('tlMetric', function () {

    this.$get = ['tlDataFactory', function (tlDataFactory) {

      var methods = {
        // batch({list})
        'batch': {},
        // track({...})
        'track': {},
        // frontend({...})
        'frontend': {}
      };

      var tlMetric = tlDataFactory(methods, {
        namespace: 'metric'
      });

      // fire & forget
      tlMetric.$send = tlMetric.$emit;

      return tlMetric;
    }];
  });

  _module.factory('tlAuth', ['tlDataFactory', function (tlDataFactory) {

    var methods = {
      // auth()
      // auth({username, password})
      'auth': {},
      // changeCompany({orgId})
      'changeCompany': {},
      // logout()
      'logout': {}
    };

    return tlDataFactory(methods);
  }]);

  _module.factory('tlFile', ['tlDataFactory', function (tlDataFactory) {

    var methods = {
      // {list: [{spaceId, fileId, fileName, alt}]}
      'getDownloadUrl': {},
      // getFiles({sort, limit, order, offset, spaceId})
      'getFiles': {},
      // getUploadUrl({spaceId})
      'getUploadUrl': {},
      // getTempUploadUrl({})
      'getTempUploadUrl': {},
      // commitFiles({tempSpaceId, spaceId})
      'commitFiles': {}
    };

    return tlDataFactory(methods);
  }]);

  _module.factory('tlCollabFiles', ['tlDataFactory', function (tlDataFactory) {

    var methods = {
      // confirm({fileUids: [uid1, uid2, ...]})
      'confirm': {},
      // createShareUrl({fileUid})
      'createShareUrl': {}
    };

    return tlDataFactory(methods, {
      namespace: 'collabFiles'
    });
  }]);

  _module.factory('tlRoom', ['tlDataFactory', function (tlDataFactory) {
    var methods = {
      'getRoom': { version: 'rooms.v2' },
      'getRooms': { version: 'rooms.v2' },
      'updateRoomUser': { version: 'rooms.v2' },
      'newRoom': { version: 'rooms.v2' },
      'updateRoom': { version: 'rooms.v2' },
      'removeUser': { version: 'rooms.v2' },
      'getMessageCounts': { version: 'rooms.v2' },
      'reorderFavorites': { version: 'rooms.v2' },
      'subscribeUserToRoom': { version: 'rooms' },
      'subscribeUsersToRoom': { version: 'rooms' },
      'getLastRead': { version: 'rooms.v2' },
      'getBroadcastsForUser': { version: 'rooms' },
      'getOneOnOneRoom': {},
      'getObjectReferences': {},

      'getStories': { version: 'rooms.v2' },
      'newStory': { version: 'rooms.v2' },
      'updateStory': { version: 'rooms.v2' },
      'deleteStory': { version: 'rooms.v2' },

      'ping': { version: 'rooms' },
      'healthcheck': { version: 'rooms' },
      'hasExceededLimitOfRoomsToPostInPerDay': { version: 'rooms' },
      'updateObjectReference': { version: 'rooms' }
    };

    return tlDataFactory(methods);
  }]);

  _module.factory('tlSearch', ['tlDataFactory', function (tlDataFactory) {

    var methods = {
      // spotlight({query})
      'spotlight': { version: 'v2' },
      // search({query})
      // search({query, section})
      'search': { version: 'v2' },
      // browseRoomAndUser({query, config})
      'browseRoomAndUser': { version: 'v2' },
      //lightweight is-up type check
      'ping': {}
    };

    return tlDataFactory(methods, {
      namespace: 'search'
    });
  }]);

  _module.factory('tlSearch3', ['tlDataFactory', function (tlDataFactory) {

    var methods = {
      // spotlight({query})
      'spotlight': { version: 'v3' },
      // search({query})
      // search({query, section})
      'search': { version: 'v3' },
      // browseRoomAndUser({query, config})
      'browseRoomAndUser': { version: 'v3' },
      //lightweight is-up type check
      'ping': {}
    };

    return tlDataFactory(methods, {
      namespace: 'search'
    });
  }]);

  _module.factory('tlSearch4', ['tlDataFactory', function (tlDataFactory) {

    var methods = {
      'spotlight': { version: 'v4' }
    };

    return tlDataFactory(methods, {
      namespace: 'search'
    });
  }]);

  _module.factory('tlStory', ['tlDataFactory', function (tlDataFactory) {

    var methods = {
      // updateStoryNotes({storyId:<storyId>, notes: { isFavorite: <true|false> });
      'updateStoryNotes': {},
      //getFavoriteStories()
      'getFavoriteStories': {},
      'broadcastStory': {}
    };

    return tlDataFactory(methods);
  }]);

  _module.factory('tlUser', ['tlDataFactory', function (tlDataFactory) {

    var methods = {
      // getUsers({ids: [userId1, userId2,...]})
      // getUsers({limit})
      // getUsers({query, excludeUserIds?, excludeRoomId?})
      'getUsers': {},
      'getInvitations': {},
      // resolveInvitedUsers({userEmail, recepientEmail})
      'resolveInvitedUsers': {},
      // canInviteUser()
      'canInviteUser': {},
      // getPresence({ids: [userId1, userId]})
      'getPresence': {},
      // getProfile({})
      'getProfile': {},
      // blockPerson({userId})
      'blockPerson': {},
      // unblockPerson({userId})
      'unblockPerson': {},
      // getMessageCounts({})
      'getMessageCounts': {},
      /** getBlockInfo()
       * Response: an object with two properties
       * - blocked: an array of user ids that the authenticated user has blocked
       * - blockedBy: an array of user ids that are blocking the authenticated user
       */
      'getBlockInfo': {},
      /** canBlock({userIds:[<userId>, ...]})
       * Request: an array of user IDs for which to fetch 'canBlock' status
       * Response: a list of boolean values whose order is guaranteed to match the order of the input user Ids array.
       */
      'canBlock': {}
    };

    return tlDataFactory(methods);
  }]);

  _module.factory('tlConnections', ['tlDataFactory', function (tlDataFactory) {

    var methods = {
      'getMentions': {},
      'getContacts': {},
      'invite': {},
      'blockPerson': { version: 'v2' },
      'getInvitations': { version: 'v2' },
      'unblockPerson': { version: 'v2' },
      'resolveInvitedUsers': { version: 'v2' },
      'canInviteUser': { version: 'v2' },
      'getBlockInfo': { version: 'v2' },
      'canBlock': { version: 'v2' }
    };

    return tlDataFactory(methods, {
      namespace: 'connections'
    });
  }]);

  _module.factory('tlConnections3', ['tlDataFactory', function (tlDataFactory) {

    var methods = {
      // {userId, orgId, companyId, roomId, source, query, offset, limit, excludeIds, sort, includeIds}
      'getMentions': {},
      // {userId, orgId, companyId, source, query, email, offset, limit, excludeIds, includeIds,
      // sort, checkUsername, includeBlocked}
      'getContacts': {},
      // {userId, orgId, invite}
      'invite': {},
      // {userId, blockeePersonId}
      'blockPerson': {},
      // {userId, orgId, email,orgId,roomId,invitedBy,status,offset,limit,invitedByUid}
      'getInvitations': {},
      // {userId, blockeePersonId}
      'unblockPerson': {},
      // {obusEvent}
      'resolveInvitedUsers': {},
      // {userId, orgId}
      'canInvite': {},
      // {userId}
      'getBlockInfo': {},
      // {userId, uids}
      'canBlock': {}
    };

    return tlDataFactory(methods, {
      namespace: 'workplaceConnectionsAS'
    });
  }]);

  _module.factory('tlSettings', ['tlDataFactory', function (tlDataFactory) {

    var methods = {
      'getPreferencesByComponent': {},
      // getSettings({})
      'getSettings': {},
      // saveSettings({})
      'saveSettings': {},
      // saveMultiCompSettings({})
      'saveMultiCompSettings': {},
      // removeSettings({})
      'removeSettings': {}
    };

    return tlDataFactory(methods, {
      namespace: 'prefs'
    });
  }]);

  _module.factory('tlUtil', ['tlDataFactory', function (tlDataFactory) {

    var methods = {
      // getUrlMetadata({url})
      'getUrlMetadata': {}
    };

    return tlDataFactory(methods);
  }]);

  _module.factory('tlDirectory', ['tlDataFactory', function (tlDataFactory) {

    var methods = {
      // getOrganization({uid:orgUid})
      'getOrganization': {},
      'getPersons': {}
    };

    return tlDataFactory(methods, {
      namespace: 'directory'
    });
  }]);

  _module.factory('tlDirectory2', ['tlDataFactory', function (tlDataFactory) {

    var methods = {
      // getOrganization({uid:orgUid})
      'getOrganization': {},
      // getPersons({uids, fields})
      'getPersons': {}
    };

    return tlDataFactory(methods, {
      namespace: 'directoryDSV2'
    });
  }]);

  _module.factory('tlPlugins', ['tlDataFactory', function (tlDataFactory) {

    var methods = {
      'refreshSharedSecret': {},
      'deleteIntegration': {},
      'createIntegration': { version: 'v2' },
      'updateIntegration': { version: 'v2' },
      'getIntegrationById': { version: 'v2' },
      'getApplicationById': { version: 'v2' },
      'getApplicationList': { version: 'v2' },
      'getGoogleOauthUrl': {},
      'googleDriveStoreAccessToken': {},
      'isAuthorized': {},
      'getTokenOrAuthorizationUrl': {},
      'googleDriveLogout': {},
      'getIntegrationsGroupedByApplications': {},
      'getIntegrationsGroupedByApplicationId': {},
      'hasAuthorized': {},
      'googleCalendarLogout': {},
      'getGoogleCalendarOauthUrl': {},
      'googleCalendarStoreAccessTokenFromOauthCode': {},
      'getGoogleCalendars': {},
      'createGoogleCalendarIntegration': {},
      'deleteGoogleCalendarIntegration': {},
      'getGoogleCalendarIntegrationById': {},
      'updateGoogleCalendarIntegration': {}
    };

    return tlDataFactory(methods, {
      namespace: 'plugins'
    });
  }]);

  _module.factory('tlOrpc', ['tlDataFactory', function (tlDataFactory) {

    var methods = {
      'getProfileUrl': { version: 'v2' }
    };

    return tlDataFactory(methods, {
      namespace: 'orpc'
    });
  }]);
});
